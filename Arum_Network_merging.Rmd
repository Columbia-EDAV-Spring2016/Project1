---
title: "Arum_Network"
author: "team"
date: "February 9, 2016"
output: html_document
---
```{r,results='asis',tidy=FALSE, echo=FALSE, fig.align='center'}
# please include these libraries - Arum
library(plyr)
library(magrittr)
library(igraph)
library(statnet)
library(qgraph)
```

```{r,results='asis',tidy=FALSE, echo=FALSE, fig.align='center'}
#Load CSV file into Data Frame
df = read.csv("Survey+Response.csv")
col.list = c("Matlab", "R", "Github", "Excel", "SQL", "RStudio", "ggplot2", "shell (terminal / command line)", "C/C++", "Python", "Stata", "LaTeX", "XML", "Web: html css js", "google drive (formerly docs)", "Sweave/knitr","dropbox", "SPSS", "regular expressions (grep)", "lattice" )

#Count Columns with NAs
na.check = df%>%is.na() %>% apply(2,sum)

#Remove NAs
df_clean = df[,which(na.check==0)]

#Create colums initializing at 0
df_clean[,col.list] = 0

for(i in col.list){
  #Need an If Statement because of R vs RStudio. 
    if(i == "R"){ 
      #Use Reg expressions "R,|R$" which looks for "R," and for "R$" which means there is nothing after R (line 87 caused this issue)
      fnd = "R,|R$"
      #try to find fnd within the vector, return Row # if True
      rows = grep(pattern = fnd, x = df_clean$Experiences.with.tools)
    }else{
      #Same as above
      fnd = paste(i, sep = "")
      rows = grep(pattern = fnd, x = df_clean$Experiences.with.tools, fixed = TRUE)
      }
    df_clean[rows,i] = 1
}
```

Redivide Programs into 4 groups. And rename the super-long names of skill proficiency.

```{r}
Program <- rep(0,114)
for(i in 1:114){
  if(df_clean$Program[i] %in% c("Data Science", "IDSE (master)", "Ms in ds", "MSDS")){
    Program[i] <- "MS_DS"
}
  else if(df_clean$Program[i] == "Data Science Certification"){
    Program[i] <- "Certificate_DS"
  }
  else if(df_clean$Program[i] == "Statistics (master)"){
    Program[i] <- "MA_Stat"
  }
  else{
   Program[i] <- "Others"
  }
}
df_clean$Program <- as.factor(Program)
names(df_clean) [c(4:5,7:11)] <- c("r_data_modeling_experience","gender","r_graphics_experience",
                                 "r_advanced_multivariate_analysis_experience",
                                 "r_markdown_experience",
                                 "matlab_experience","github_experience")
```




Arum's Code
```{r, echo=FALSE}
# Modified skill names
sk_list =c("Matlab", "R", "Github", "Excel", "SQL", 
           "RStudio", "ggplot2", "Shell", "C_CPP", "Python", 
           "Stata", "LaTeX", "XML", "Web", "Google Drive", 
           "Sweave_knitr", "Dropbox", "SPSS", "Regular Expression", "lattice")

# Category of each skill set, we can adjust as needed. (ST: Statistics, GE: General, CS: Computer Science)
area_list <- c("ST", "ST", "GE", "ST", "CS", 
               "ST", "ST", "CS", "CS", "CS", 
               "ST", "GE", "CS", "CS", "GE", 
               "ST", "GE", "ST", "CS", "ST")
area_color <- c("SkyBlue", "SkyBlue", "Green", "SkyBlue", "Yellow",
                "SkyBlue", "SkyBlue", "Yellow", "Yellow", "Yellow",
                "SkyBlue", "Green", "Yellow", "Yellow", "Green",
                "SkyBlue", "Green", "SkyBlue", "Yellow", "SkyBlue")

df_for_network = data.frame(df_clean)
colnames(df_for_network)[c(12:31)] <- sk_list   

sk_sum <- apply(df_for_network[12:31], 2, sum) # Total number of students who chose it
sk_set <- data.frame(sk_sum, round(sk_sum/nrow(df_for_network)*100, 0), area_list, area_color) # Summary of skill set
colnames(sk_set) <- c("Number of Students", "Percentage of Students", "Area", "Vertex Color")

num_student = nrow(df_for_network)
num_sk = length(sk_list)

# (1) Adjacency matrix ((A, B): the number of student selected both A and B skills)
sk_rel = data.frame(matrix(rep(0,num_sk*num_sk), ncol = num_sk, nrow = num_sk))
colnames(sk_rel) = sk_list
rownames(sk_rel) = sk_list

for(i in 1:num_student) {
  for(sk1 in sk_list) {
    for(sk2 in sk_list) {
      if((df_for_network[i, sk1] == 1 && df_for_network[i, sk2] == 1) && (sk1 != sk2)) {
        sk_rel[sk1, sk2] = sk_rel[sk1, sk2] + 1
        # Set weight between same skill (Matlab, Matlab) as 0
      }
    }
  }
}

# (2) Adjacency matrix ((A, B): % of students who chose B among students who chose A = Pr(B|A))
sk_per = data.frame(matrix(rep(0,num_sk*num_sk), ncol = num_sk, nrow = num_sk))
colnames(sk_per) = sk_list
rownames(sk_per) = sk_list

for(sk1 in sk_list) {
  for(sk2 in sk_list) {
    if(sk1 != sk2) {
      sk_per[sk1, sk2] = round(sk_rel[sk1, sk2] / sk_set[sk1, 1] * 100, 0)
      # (Matlab, R) : % of students who chose R among the student who chose Matlab = Pr(R|Matlab)
    }
    else {
      sk_per[sk1, sk2] = sk_set[sk1, 2]
      # (Matlab, Matlab) : % of students who chose Matlab
    }
  }
}

# (3) Adjacency matrix (Same as (2), but only shows (A, B) when (A, B) - (B, B) > threshold)
# It means knowing that the student chose A, he has higher probability of also having B than 
# the probability of having B without the information

sk_dif = data.frame(matrix(rep(0,num_sk*num_sk), ncol = num_sk, nrow = num_sk))
colnames(sk_dif) = sk_list
rownames(sk_dif) = sk_list
dif_cri = 20 # Threshold for choosing which edge to show

for(sk1 in sk_list) {
  for(sk2 in sk_list) {
    if(sk1 != sk2) {
      if(sk_per[sk1, sk2]-sk_per[sk2, sk2] > dif_cri) 
      {
        sk_dif[sk1, sk2] = round(sk_per[sk1, sk2], 0)
        # This value is 0, if difference is below dif_cri. It's to show only significant differences.
        # If dif_cri=20, it only shows edges with difference of more than 20.
      }
    }
  }
}

```

```{r, echo=FALSE, fig.align='center'}

# Configure graph 

fradj = as.matrix(sk_dif)
frnet = graph.adjacency(fradj, weight=TRUE)

V(frnet)$label = paste(rownames(sk_set), '(', sk_set$`Percentage of Students`, ')')
V(frnet)$color = area_color # Color of vertices
E(frnet)$arrow.mode = ">" # forward arrow
E(frnet)$curved = 0.5 # make edges curved

# Manually setting location of each vertex. 
# (a, b), a: column. start from the left, b: row, start from the bottom
node_layout = matrix(c(3, 7, # Matlab
                      11, 7, # R
                      12, 2, # Github
                      13, 7, # Excel
                      6, 1, # SQL
                      15, 6, # RStudio
                      9, 4, # ggplot2
                      10, 1, # Shell
                      6, 6, # C_CPP
                      15, 5, # Python
                      9, 8, # Stata
                      15, 3, # LaTeX
                      6, 5, # XML
                      1, 2, # Web
                      3, 6, # Google Drive
                      9, 6, # Sweave_knitr
                      1, 5, # Dropbox
                      6, 8, # SPSS
                      3, 3, # Regular Expression
                      13, 5), # lattice
                     nrow=20, byrow=TRUE)

plot.igraph(frnet, layout=node_layout, edge.arrow.size=0.2, 
            vertex.size=sk_sum/4, vertex.label.color="black", 
            edge.width = E(frnet)$weight/15, edge.label = E(frnet)$weight)

tkplot(frnet, layout=node_layout, vertex.size = sk_sum*0.8,
       vertex.label.color="black", edge.label = E(frnet)$weight,
       edge.width = E(frnet)$weight/15, edge.arrow.size = 2)

qnet = as.matrix(sk_dif)
qgraph(qnet, edge.labels=TRUE, layout=node_layout, vertex.size = sk_sum, width=10, height=10, normalize=FALSE, vsize=3, asize=1, edge.label.cex=0.7, label.scale=FALSE, label.cex=0.7, labels=sk_list, shape="circle")

```

This graph shows the information about percentage of students who chose each skill. 

Each vertex represents a skill. The vertex label shows the name of the skill and the percentage of students who chose each skill from the entire students. The higher the percentage is, the bigger the vertex is. The color of vertex represents the area of the skill. We classified each skill in to three areas: Computer Science (Yellow), Statistics (Blue), and General (Green). 

Edge (A->B) show that knowing that the student chose a skill – A, he has higher probability of also having skill B. For example, the probability of a student having SQL is 49%, but when we know that the student chose web, the probability of the student also having SQL is 88%. 
We set a threshold of 20, to only show bigger differences. For example, percentage of students who chose RStudio is 76%, and percentage of students who chose RStudio among who chose R is 90%. Even though 90% looks very high, because the difference of percentage is 14%, that doesn’t show on this graph.

Another interesting characteristic is that the rare skills (represented by smaller vertex sizes) such as Sweave_knitr, lattice, and Regular expression have thicker edges with many other skills. A possible explanation is that these skills are rare because they are more advanced skills. Then, it makes sense for a student who have advanced skills to have many other skills as well.

We can also see that skills in a same area tend to have more number of edges. However, in case of general skills – Google Drive, Dropbox, Github, and LaTeX, they seem to have stronger relationships with computer science skills then statistics skills. This makes sense, because students with computer science background tend to use these type of skills more often than others. 

In case of Python, it has strong relationship only with lattice. This might be because the majority of students are data science masters and data science certification, and majority of them took algorithm class last semester, where we used Python. I think because majority of students used Python regardless of their previous experience or background, Python didn’t show any strong relationship with other skill.

